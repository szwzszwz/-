# 最长公共子序列

给定两个长度分别为 **N** 和 **M** 的字符串 **A** 和 **B**，求既是 **A** 的子序列又是 **B** 的子序列的字符串长度最长是多少。

#### 输入格式

第一行包含两个整数 **N** 和 **M**。

第二行包含一个长度为 **N** 的字符串，表示字符串 **A**。

第三行包含一个长度为 **M** 的字符串，表示字符串 **B**。

字符串均由小写字母构成。

#### 输出格式

输出一个整数，表示最大长度。

#### 数据范围

**1  ≤  N , M  ≤  1000**

#### 输入样例：

```
4 5
acbd
abedc
```

#### 输出样例：

```
3
```





## *代码*

```cpp
// f[i][j]  所有在第一个序列前i个字母出现，第二个序列前j个字母出现的公共子序列

// 集合的划分--总共： f[i][j]
// 类型：11  <==>  f[i - 1][j - 1] + 1   i、j都选
// 类型：01  <=  f[i - 1][j] <=  f[i][j]  选j，不选i（可以用f[i - 1][j]来代替01这个类型）
// 类型：10  <=  f[i][j - 1] <=  f[i][j]  选i，不选j（可以用f[i][j - 1]来代替10这个类型）
// 类型：00  <==>  f[i - 1][j - 1]  i、j都不选

#include<iostream>
#include<algorithm>

using namespace std;

const int N = 1010;
int n, m;
char a[N], b[N];
int f[N][N];

int main()
{
	scanf("%d%d", &n, &m);
	scanf("%s%s", a + 1,b + 1);
	for(int i = 1;i <= n;i++)
		for(int j = 1;j <= m;j++){
			f[i][j] = max(f[i - 1][j], f[i][j - 1]); // 这两个包含了类型：00
			if(a[i] == b[j]) f[i][j] = max(f[i - 1][j - 1] + 1, f[i][j]); // 只有最后一位数字相同的时候，才能出现i和j都选了
		}
	cout << f[n][m];
	return 0;
}
```

